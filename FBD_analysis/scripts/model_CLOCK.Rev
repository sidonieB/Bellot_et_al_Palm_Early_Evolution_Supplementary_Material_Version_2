############################################################################################################################################################################################################
# This is the script where we define the molecular clock
# Copied and adapted from https://revbayes.github.io/tutorials/fbd/ Tutorial written by Tracy A. Heath, April M. Wright, and Walker Pett, Last modified on August 13, 2024 (hereafter "Tutorial")
# and from https://github.com/mlandis/vib_div/tree/master/code code used in Landis et al., 2021 Systematic Biology 70: 67–85 (hereafter "Landis")
# and from https://github.com/spiritu-santi/Biogeography/tree/main/rb_out/FBD/code code used in Ramírez-Barahona, 2024 Evolution 78: 919–933 (hereafter "Santiago")
############################################################################################################################################################################################################



#########################################################################
# Only modify if poor mixing or if want to change the model
#########################################################################


# Distribution from which the mean substitution rate will be sampled

branch_rates_mean ~ dnExponential(20) # Tutorial mean: 10, Santiago put the mean to 20 and has set this in addition: branch_rates_mean.setValue(0.00032). He did this because tree ferns are notorious for having short branches and low rates of substitution but says that we can safely keep 10 here
branch_rates_mean.setValue(0.0005) #SRB# Looking art first results, I would put this to jump start the mcmc chain.
#moves.append( mvScale(branch_rates_mean, lambda=0.01, weight=5.0) ) # Tutorial weight: 1, Santiago puts the weight of this one to 5 #SRB#
#moves.append( mvScale(branch_rates_mean, lambda=0.1,  weight=1.0) ) # Tutorial weight: 1, Santiago misses this one
#moves.append( mvScale(branch_rates_mean, lambda=1.0,  weight=1.0) ) # Tutorial weight: 1 #SRB#

#moves[mvi++] = mvScale(branch_rates_mean, lambda = 1.0, weight=1)  #SRB#
moves[mvi++] = mvScale(branch_rates_mean, lambda = 0.001, weight=5)  #SRB#

# Number of branches
n_branches <- 2 * n_taxa - 2

# Distributions from which the rate of substitution will be sampled for each branch (one distribution per branch, all distributions have a mean drawn from the above distribution)
for(i in 1:n_branches){
    branch_rates[i] ~ dnExp(1/branch_rates_mean)
    #moves.append( mvScale(branch_rates[i], lambda=1.0,  weight=3.0) ) # Tutorial weight: 1, Santiago puts the weight of this one to 3 #SRB#
    #moves.append( mvScale(branch_rates[i], lambda=0.1,  weight=1.0) ) # Tutorial weight: 1, Santiago misses this one
    #moves.append( mvScale(branch_rates[i], lambda=0.01, weight=1.0) ) # Tutorial weight: 1 #SRB#
    moves[mvi++] = mvScale(branch_rates[i], lambda = 1.0,  weight = 1) #SRB#
    moves[mvi++] = mvScale(branch_rates[i], lambda = 0.01, weight = 3) #SRB#
}

# moves on all rates at once, to improve mixing
#moves.append( mvVectorScale(branch_rates, lambda=0.01, weight=4.0) ) # Tutorial weight: 4 #SRB#
#moves.append( mvVectorScale(branch_rates, lambda=0.1,  weight=4.0) ) # Tutorial weight: 4, Santiago misses this one
#moves.append( mvVectorScale(branch_rates, lambda=1.0,  weight=4.0) ) # Tutorial weight: 4 #SRB#

moves[mvi++] = mvVectorScale(branch_rates, lambda = 0.01, weight=4.0) #SRB#
moves[mvi++] = mvVectorScale(branch_rates, lambda = 1.0,  weight=2.0) #SRB# reducing weight to improve mixing. So we have more often small moves than large moves.
