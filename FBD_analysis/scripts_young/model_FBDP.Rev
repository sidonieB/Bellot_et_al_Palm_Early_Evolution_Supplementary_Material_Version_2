############################################################################################################################################################################################################
# This is the script where we define the FBD model
# Copied and adapted from https://revbayes.github.io/tutorials/fbd/ Tutorial written by Tracy A. Heath, April M. Wright, and Walker Pett, Last modified on August 13, 2024 (hereafter "Tutorial")
# and from https://github.com/mlandis/vib_div/tree/master/code code used in Landis et al., 2021 Systematic Biology 70: 67–85 (hereafter "Landis")
# and from https://github.com/spiritu-santi/Biogeography/tree/main/rb_out/FBD/code code used in Ramírez-Barahona, 2024 Evolution 78: 919–933 (hereafter "Santiago")
############################################################################################################################################################################################################



####################################
# Values to modify
####################################
orig_min        = 113                              # minimum origin time
if(old) orig_max = 206                             # maximum origin time
if(!old) orig_max = 125                            # maximum origin time
orig_init       = (orig_min + orig_max)/2          # initial origin time
if(old) orig_init = 154 
samp_frac       = 0.074                            # Probability of sampling extant taxa (for instance if we have 186 species out of the ca. 2522 extant palm species, it will be 187/2522 = 0.074)



#########################################################################
# Only modify below if poor mixing or if want to change the model
#########################################################################


##################################################################################################
# Generalities to remember about moves
# mvSlide: sliding window move: samples a parameter uniformly within an interval (defined by the half-width delta). Sliding window moves can be tricky for small values, as the window may overlap zero, but will be ok for things such as origin_time
# mvScale: scaling move: proposes multiplicative changes to a parameter where a tuning value called lambda determines the size of the proposed change.
# By using multiple moves for a single parameter, we will improve the mixing of the Markov chain.
# Tunetarget is the acceptance probability targeted by auto-tuning. Default : 0.44
##################################################################################################



####################################################
# Define priors for speciation and extinction rates
# Use approach from Santiago and Landis
# Tutorial approach pasted at the end for reference
####################################################

# Speciation and extinction rates are not defined directly, but estimated from diversification and turnover
# MCMC moves operate on diversification and turnover
# From Landis et al., 2021 Supplementary Material
# "We assigned a lognormal prior to the net diversification rate (birth rate minus death rate, λ − μ) centered on the value that generates 163 taxa after 65 Myrs, and with a shape parameter (lognormal standard deviation) of 0.5 (Nee et al., 1994). "
# This sounds as n_taxa below should be only the extant taxa, but when looking at the code of Landis, n_taxa includes the fossils (ie it is 168, not 163). Santiago also includes the fossils and confirms that they should be included because the fossil and extant taxa are part of the same tree-generating model.
# Following the same idea, we use our number of taxa and our maximum origin age
div_sd <- 0.5
div_mean := ln( abs( ln(n_taxa/2) ) / orig_max) - 0.5 * div_sd^2
diversification ~ dnLognormal(mean = div_mean, sd = div_sd)
diversification.setValue(0.035)
turnover ~ dnBeta(10,2) # Landis uses Bedta(2,2) as per his OSM or Beta(1,1) as per his code
turnover.setValue(0.6)

speciation_rate := diversification / abs(1.0 - turnover)
extinction_rate := turnover * speciation_rate

# Fossilization rate is not defined directly, but as a fraction of speciation rate
psi_f ~ dnBeta(1,200) # Landis uses dnBeta(1,100)
psi_f.setValue(0.012) # Landis uses psi_f.setValue(0.01)
psi := speciation_rate * psi_f

# Moves: (Same for Santiago and Landis)
tune_targets = [ 0.1, 0.44, 0.65 ]
tune_weights = [ 2, 5, 5 ]
for (i in 1:tune_targets.size()) {
    #moves.append( mvScale(diversification, weight=tune_weights[i], tuneTarget=tune_targets[i], lambda=0.5) )
    #moves.append( mvSlide(turnover, weight=tune_weights[i], tuneTarget=tune_targets[i], delta=0.2) )
    #moves.append( mvSlide(psi_f, weight=tune_weights[i], tuneTarget=tune_targets[i], delta=0.2) )
    moves[mvi++] = mvScale(diversification, weight=tune_weights[i], tuneTarget=tune_targets[i], lambda=0.5) #SRB#
    moves[mvi++] = mvScale(diversification, weight=tune_weights[i], tuneTarget=tune_targets[i], lambda=1) #SRB#
    moves[mvi++] = mvSlide(turnover, weight=tune_weights[i], tuneTarget=tune_targets[i], delta=0.2) #SRB#
    moves[mvi++] = mvSlide(turnover, weight=tune_weights[i], tuneTarget=tune_targets[i], delta=0.5) #SRB#
    moves[mvi++] = mvSlide(psi_f, weight=tune_weights[i], tuneTarget=tune_targets[i], delta=0.2) #SRB#
}


#########################################################
# Other parameters and associated moves
#########################################################

## Probability of sampling extant taxa 
rho <- samp_frac


## Origin time
# The origin time is when the FBD process starts, in other words it is the ancestral node to the root, where the root is the crown group of all extant + fossil taxa
origin_time ~ dnUnif(orig_min, orig_max)
#origin_time ~ dnExponential(0.2, offset = 113)
origin_time.setValue(orig_init)

#moves.append( mvSlide(origin_time, delta=0.01, weight=5.0) ) # Tutorial weight 5, Santiago misses this one
#moves.append( mvSlide(origin_time, delta=0.1,  weight=1.0) ) # Tutorial weight 5, Santiago put it at 1 #SRB#
#moves.append( mvSlide(origin_time, delta=1,    weight=5.0) ) # Tutorial weight 5, Santiago misses this one
moves[mvi++] = mvSlide(origin_time, delta = 0.01,  weight = 2) #SRB#
moves[mvi++] = mvSlide(origin_time, delta = 0.1,  weight = 1) #SRB#
moves[mvi++] = mvSlide(origin_time, delta = 1 ,  weight = 5) #SRB# added an extra move with twice the weight but larger moves, to make mixing more efficient.


## Tree
# Define the tree prior distribution based on the above parameters
# condition="survival" prevents us to sample trees where some of our extant taxa would be extinct (I think)
# dnFBDP is when we do not have stratigraphic ranges

fbd_dist = dnFBDP(origin=origin_time, lambda=speciation_rate, mu=extinction_rate, psi=psi, rho=rho, taxa=taxa, condition="survival")



## Define the final constrained tree prior distribution:
# constraints are defined in a separate script
# fbd_tree ~ dnConstrainedTopology(fbd_dist, backbone=tree_backbone, constraints=constraints)
fbd_tree ~ dnConstrainedTopology(fbd_dist, constraints=constraints)

## Set initial tree (facultative)
# fbd_tree.setValue(tree_init)



## Constrain the placement of the fossils to be in their age interval

fossils = fbd_tree.getFossils()
for(i in 1:fossils.size())
{
    t[i] := tmrca(fbd_tree, clade(fossils[i]))

    a_i = fossils[i].getMinAge()
    b_i = fossils[i].getMaxAge()

    F[i] ~ dnUniform(t[i] - b_i, t[i] - a_i)
    F[i].clamp( 0 )
}

#moves.append( mvFossilTimeSlideUniform(fbd_tree, origin_time, weight=5.0) ) # Tutorial weight 5 #SRB#
#moves.append( mvFossilTimeSlideUniform(fbd_tree, origin_time, weight=1.0) ) # Tutorial misses this one #SRB#
moves[mvi++] = mvFossilTimeSlideUniform(fbd_tree, origin_time, weight=5.0) #SRB#
moves[mvi++] = mvFossilTimeSlideUniform(fbd_tree, origin_time, weight=1.0) #SRB#






## Create a deterministic node called num_samp_anc that will compute the number of sampled ancestors in our fbd_tree.
num_samp_anc := fbd_tree.numSampledAncestors();

## Define a pruned tree without fossils in case needed
pruned_tree := fnPruneTree(fbd_tree, prune = v("R215__Mauritiidites_sp_1"), pruneFossils=TRUE) #SRB# # NEED TO ADD A SINGLE TAXON TO 'prune' FOR IT TO WORK.... THE MISTERIES OF THE REVEREND




## Further moves:
# change in topology
#moves.append( mvFNPR(fbd_tree, weight=15.0) ) # Tutorial weight at 15, Landis put the weight to n_branches/4) #SRB#
# change a node time
#moves.append( mvNodeTimeSlideUniform(fbd_tree, weight=20.0) ) # Tutorial weight at 40, Santiago put the weight at 20, Landis put it at n_branches*2 #SRB#
# change position of fossil to be on its own branch or on a branch leading to extant taxon
#moves.append( mvCollapseExpandFossilBranch(fbd_tree, origin_time, weight=6.0) ) # Tutorial weight at 6, Landis put the weight at 10 #SRB#
# change root age
#moves.append( mvRootTimeSlideUniform(fbd_tree, origin_time, weight=5.0) ) # Tutorial weight at 5, Landis put the weight at 30 #SRB#

#moves[mvi++] = mvNNI(fbd_tree, weight=10) #SRB#
moves[mvi++] = mvFNPR(fbd_tree, weight=15.0) #SRB#
moves[mvi++] = mvNodeTimeSlideUniform(fbd_tree, weight=20.0) #SRB#
moves[mvi++] = mvCollapseExpandFossilBranch(fbd_tree, origin_time, weight=6.0) #SRB#
moves[mvi++] = mvRootTimeSlideUniform(fbd_tree, origin_time, weight=5.0) #SRB#






################################################################################
# Tutorial approach for defining speciation and extinction rates (not used)
################################################################################
# An exponential distribution with δ=10 has an expected value (mean) of 1/10
# speciation_rate ~ dnExponential(10)
# extinction_rate ~ dnExponential(10)
# Define moves for the two above parameters
# if a move is not specified for a stochastic node, then it will not be estimated, but fixed to its initial value)
# lambd is the size of the change compared to previous value
# 3 moves per parameter improves mixing
# Within a cycle, an individual move is chosen from the move list in proportion to its weight.
# So in a dummy context where 6 moves are allowed per chain step, and that's the only moves we have, with all six moves assigned weight=1, each would have an equal probability of being executed and would be performed on average one time per MCMC cycle.
# moves.append( mvScale(speciation_rate, lambda=0.01, weight=1) )
# moves.append( mvScale(speciation_rate, lambda=0.1,  weight=1) )
# moves.append( mvScale(speciation_rate, lambda=1.0,  weight=1) )
# moves.append( mvScale(extinction_rate, lambda=0.01, weight=1) )
# moves.append( mvScale(extinction_rate, lambda=0.1,  weight=1) )
# moves.append( mvScale(extinction_rate, lambda=1,    weight=1) )
# Define additional parameters that depend on the extinction and speciation rates, in case we are interested in them:
# diversification := speciation_rate - extinction_rate
# turnover := extinction_rate/speciation_rate
# Fossil sampling rate
# Tutorial uses: psi ~ dnExponential(10) 
# Santiago and Landis define it as a fraction of speciation rate instead (see below)
# psi ~ dnExponential(10) 
# moves.append( mvScale(psi, lambda=0.01, weight=1) ) # Tutorial weight is 1, Santiago misses this one
# moves.append( mvScale(psi, lambda=0.1,  weight=1) ) # Tutorial weight is 1, Santiago misses this one
# moves.append( mvScale(psi, lambda=1,    weight=1) ) # Tutorial weight is 1, Santiago misses this one
